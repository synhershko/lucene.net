<html dir="LTR">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=Windows-1252" />
    <meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5" />
    <title>ExpungeDeletes Method</title>
    <xml>
    </xml>
    <link rel="stylesheet" type="text/css" href="MSDN.css" />
  </head>
  <body id="bodyID" class="dtBODY">
    <div id="nsbanner">
      <div id="bannerrow1">
        <table class="bannerparthead" cellspacing="0">
          <tr id="hdr">
            <td class="runninghead">Apache Lucene.Net 2.4.0 Class Library API</td>
            <td class="product">
            </td>
          </tr>
        </table>
      </div>
      <div id="TitleRow">
        <h1 class="dtH1">IndexWriter.ExpungeDeletes Method</h1>
      </div>
    </div>
    <div id="nstext">
      <p> Expunges all deletes from the index. When an index has many document deletions (or updates to existing documents), it's best to either call optimize or expungeDeletes to remove all unused data in the index associated with the deleted documents. To see how many deletions you have pending in your index, call {@link IndexReader#numDeletedDocs} This saves disk space and memory usage while searching. expungeDeletes should be somewhat faster than optimize since it does not insist on reducing the index to a single segment (though, this depends on the {@link MergePolicy}; see {@link MergePolicy#findMergesToExpungeDeletes}.). Note that this call does not first commit any buffered documents, so you must do so yourself if necessary. See also {@link #expungeDeletes(bool)} </p>
      <h4 class="dtH4">Overload List</h4>
      <p> Expunges all deletes from the index. When an index has many document deletions (or updates to existing documents), it's best to either call optimize or expungeDeletes to remove all unused data in the index associated with the deleted documents. To see how many deletions you have pending in your index, call {@link IndexReader#numDeletedDocs} This saves disk space and memory usage while searching. expungeDeletes should be somewhat faster than optimize since it does not insist on reducing the index to a single segment (though, this depends on the {@link MergePolicy}; see {@link MergePolicy#findMergesToExpungeDeletes}.). Note that this call does not first commit any buffered documents, so you must do so yourself if necessary. See also {@link #expungeDeletes(bool)} </p>
      <blockquote class="dtBlock">
        <a href="Lucene.Net.Index.IndexWriter.ExpungeDeletes_overload_2.html">public void ExpungeDeletes();</a>
      </blockquote>
      <p> Just like {@link #expungeDeletes()}, except you can specify whether the call should block until the operation completes. This is only meaningful with a {@link MergeScheduler} that is able to run merges in background threads. </p>
      <blockquote class="dtBlock">
        <a href="Lucene.Net.Index.IndexWriter.ExpungeDeletes_overload_1.html">public void ExpungeDeletes(bool);</a>
      </blockquote>
      <h4 class="dtH4">See Also</h4>
      <p>
        <a href="Lucene.Net.Index.IndexWriter.html">IndexWriter Class</a> | <a href="Lucene.Net.Index.html">Lucene.Net.Index Namespace</a></p>
      <hr />
      <div id="footer">
        <p>
        </p>
        <p>Generated from assembly Lucene.Net [2.4.0.2]</p>
      </div>
    </div>
  </body>
</html>